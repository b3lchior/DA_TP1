<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StationsUHUH: GraphAlgorithms Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">StationsUHUH
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classGraphAlgorithms-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">GraphAlgorithms Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for GraphAlgorithms:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classGraphAlgorithms.png" usemap="#GraphAlgorithms_map" alt=""/>
  <map id="GraphAlgorithms_map" name="GraphAlgorithms_map">
<area href="classGraph.html" alt="Graph" shape="rect" coords="0,0,106,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7b5d8ca55c363d129a3aebdd6c93f53e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a7b5d8ca55c363d129a3aebdd6c93f53e">edmondsKarp</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t)</td></tr>
<tr class="memdesc:a7b5d8ca55c363d129a3aebdd6c93f53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum flow from source to sink using the Edmonds-Karp algorithm.  <br /></td></tr>
<tr class="separator:a7b5d8ca55c363d129a3aebdd6c93f53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7743bb7b0ca9666233bb6529ffb112b7"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structMaxTrainPair.html">MaxTrainPair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a7743bb7b0ca9666233bb6529ffb112b7">find_max_flow</a> ()</td></tr>
<tr class="memdesc:a7743bb7b0ca9666233bb6529ffb112b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the maximum flow between all pairs of vertices in the graph.  <br /></td></tr>
<tr class="separator:a7743bb7b0ca9666233bb6529ffb112b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc6922f78c80b5480e3e2f44d05bb02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a8fc6922f78c80b5480e3e2f44d05bb02">find_max_number_of_trains_to_station</a> (string stationID)</td></tr>
<tr class="memdesc:a8fc6922f78c80b5480e3e2f44d05bb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum number of trains that can be sent to a given station.  <br /></td></tr>
<tr class="separator:a8fc6922f78c80b5480e3e2f44d05bb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdb089cabef0c3a34d3d7fa38a3f687"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structFlowPerMunicOrDis.html">FlowPerMunicOrDis</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a8cdb089cabef0c3a34d3d7fa38a3f687">TopKMunicipesForWithMoreTraficPotencial</a> (int k)</td></tr>
<tr class="memdesc:a8cdb089cabef0c3a34d3d7fa38a3f687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the top k municipalities with the most traffic potential based on the number of trains that can be routed between stations within each municipality.  <br /></td></tr>
<tr class="separator:a8cdb089cabef0c3a34d3d7fa38a3f687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263885df52809e4bac2d5a13cb04bb80"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structFlowPerMunicOrDis.html">FlowPerMunicOrDis</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a263885df52809e4bac2d5a13cb04bb80">TopKDistricsForWithMoreTraficPotencial</a> (int k)</td></tr>
<tr class="memdesc:a263885df52809e4bac2d5a13cb04bb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the top k districts with the highest traffic potential.  <br /></td></tr>
<tr class="separator:a263885df52809e4bac2d5a13cb04bb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58685fb1a172cb92e9ec0902722c63be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a58685fb1a172cb92e9ec0902722c63be">edmondsKarpWithDijska</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t, int &amp;price)</td></tr>
<tr class="memdesc:a58685fb1a172cb92e9ec0902722c63be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum flow from source to sink using the Edmonds-Karp algorithm with Dijkstra's algorithm to compute the minimum residual capacity.  <br /></td></tr>
<tr class="separator:a58685fb1a172cb92e9ec0902722c63be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e12d57cdf79b52cc9e259ebcb6c1a85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a2e12d57cdf79b52cc9e259ebcb6c1a85">edmondsKarpReducedConnectivity</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t, vector&lt; <a class="el" href="classEdge.html">Edge</a> * &gt; edgesReduced)</td></tr>
<tr class="memdesc:a2e12d57cdf79b52cc9e259ebcb6c1a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Edmonds-Karp algorithm with reduced connectivity to find the maximum flow from s to t.  <br /></td></tr>
<tr class="separator:a2e12d57cdf79b52cc9e259ebcb6c1a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a40093e6b997399ccb1a50a70c0c4ac"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structAfectedStation.html">AfectedStation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a1a40093e6b997399ccb1a50a70c0c4ac">TopKStationsThatAreAffectedByReducedConectivity</a> (int k, vector&lt; <a class="el" href="structEdgeSearch.html">EdgeSearch</a> &gt; unusedEdges)</td></tr>
<tr class="memdesc:a1a40093e6b997399ccb1a50a70c0c4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the top K stations that are most affected by a reduced connectivity scenario caused by the removal of certain edges.  <br /></td></tr>
<tr class="separator:a1a40093e6b997399ccb1a50a70c0c4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5c7a72d06e03f76f41a117f066de8b"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#aee5c7a72d06e03f76f41a117f066de8b">getMunicipes</a> ()</td></tr>
<tr class="memdesc:aee5c7a72d06e03f76f41a117f066de8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a vector with the names of all the municipalities present in the graph.  <br /></td></tr>
<tr class="separator:aee5c7a72d06e03f76f41a117f066de8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08934472eb8ac30f48bdb5a44d8dde8a"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a08934472eb8ac30f48bdb5a44d8dde8a">getDistrics</a> ()</td></tr>
<tr class="memdesc:a08934472eb8ac30f48bdb5a44d8dde8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a vector with the names of all the districts present in the graph.  <br /></td></tr>
<tr class="separator:a08934472eb8ac30f48bdb5a44d8dde8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e07a19a5cc26bb9a453a29857bd3ce"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a12e07a19a5cc26bb9a453a29857bd3ce">findVertexsInMunicipe</a> (string municipe)</td></tr>
<tr class="memdesc:a12e07a19a5cc26bb9a453a29857bd3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a vector of all vertices in the graph that belong to a specific municipality.  <br /></td></tr>
<tr class="separator:a12e07a19a5cc26bb9a453a29857bd3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff3651d8436f69ccecad7d1b6eab42e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#abff3651d8436f69ccecad7d1b6eab42e">findVertexsInDistricts</a> (string district)</td></tr>
<tr class="memdesc:abff3651d8436f69ccecad7d1b6eab42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a vector of all vertices in the graph that belong to a specific district.  <br /></td></tr>
<tr class="separator:abff3651d8436f69ccecad7d1b6eab42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b4edc0d50b038a18315d1f91fec26c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a27b4edc0d50b038a18315d1f91fec26c">find_max_number_of_trains_to_station_with_congested_network</a> (string stationID, vector&lt; <a class="el" href="classEdge.html">Edge</a> * &gt; edgesReduced)</td></tr>
<tr class="memdesc:a27b4edc0d50b038a18315d1f91fec26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum number of trains that can be sent to a specific station with a congested network.  <br /></td></tr>
<tr class="separator:a27b4edc0d50b038a18315d1f91fec26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGraph.html">Graph</a></td></tr>
<tr class="memitem:a902c5b3eacb66d60752525ab23297a95 inherit pub_methods_classGraph"><td class="memItemLeft" align="right" valign="top"><a id="a902c5b3eacb66d60752525ab23297a95" name="a902c5b3eacb66d60752525ab23297a95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Graph</b> ()</td></tr>
<tr class="memdesc:a902c5b3eacb66d60752525ab23297a95 inherit pub_methods_classGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classGraph.html">Graph</a> object. <br /></td></tr>
<tr class="separator:a902c5b3eacb66d60752525ab23297a95 inherit pub_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c73af522cebce9c30d0145fea00f0b9 inherit pub_methods_classGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a4c73af522cebce9c30d0145fea00f0b9">findVertex</a> (const string &amp;id) const</td></tr>
<tr class="memdesc:a4c73af522cebce9c30d0145fea00f0b9 inherit pub_methods_classGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">find a vertex in the graph with the given id, if it does not exists return nullptr  <br /></td></tr>
<tr class="separator:a4c73af522cebce9c30d0145fea00f0b9 inherit pub_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3635dfc9eda6436fe0a51765e7ea1498 inherit pub_methods_classGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3635dfc9eda6436fe0a51765e7ea1498">addVertex</a> (string name, string district, string municipality, string township, string line)</td></tr>
<tr class="memdesc:a3635dfc9eda6436fe0a51765e7ea1498 inherit pub_methods_classGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vertex to the graph  <br /></td></tr>
<tr class="separator:a3635dfc9eda6436fe0a51765e7ea1498 inherit pub_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7110941de246c406c50c5311abfa29 inherit pub_methods_classGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a1c7110941de246c406c50c5311abfa29">removeVertex</a> (const string &amp;id)</td></tr>
<tr class="memdesc:a1c7110941de246c406c50c5311abfa29 inherit pub_methods_classGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove a vertex from the graph  <br /></td></tr>
<tr class="separator:a1c7110941de246c406c50c5311abfa29 inherit pub_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e12534631f32aa55bc1778da60a57e inherit pub_methods_classGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a34e12534631f32aa55bc1778da60a57e">addEdge</a> (const string &amp;sourc, const string &amp;dest, double w, string service)</td></tr>
<tr class="memdesc:a34e12534631f32aa55bc1778da60a57e inherit pub_methods_classGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a edge to a vertex of the graph  <br /></td></tr>
<tr class="separator:a34e12534631f32aa55bc1778da60a57e inherit pub_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af405eba5c4286fd0e8c2b081a17d77f7 inherit pub_methods_classGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#af405eba5c4286fd0e8c2b081a17d77f7">addBidirectionalEdge</a> (const string &amp;sourc, const string &amp;dest, double w, string service)</td></tr>
<tr class="memdesc:af405eba5c4286fd0e8c2b081a17d77f7 inherit pub_methods_classGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a edge from source to destination vertex and another edge the other way  <br /></td></tr>
<tr class="separator:af405eba5c4286fd0e8c2b081a17d77f7 inherit pub_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f19f005704401983591d3283a896a09 inherit pub_methods_classGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a8f19f005704401983591d3283a896a09">findEdge</a> (<a class="el" href="classVertex.html">Vertex</a> *dest, <a class="el" href="classVertex.html">Vertex</a> *orig, double weight, string service)</td></tr>
<tr class="memdesc:a8f19f005704401983591d3283a896a09 inherit pub_methods_classGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">find edge between two vertices  <br /></td></tr>
<tr class="separator:a8f19f005704401983591d3283a896a09 inherit pub_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bb5ad1815614ea8d548989346da414 inherit pub_methods_classGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad7bb5ad1815614ea8d548989346da414">findEdge</a> (string orig, string dest)</td></tr>
<tr class="memdesc:ad7bb5ad1815614ea8d548989346da414 inherit pub_methods_classGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">find edge between two vertices  <br /></td></tr>
<tr class="separator:ad7bb5ad1815614ea8d548989346da414 inherit pub_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459b494b4813c66585cb1d0fdc455e0c inherit pub_methods_classGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEdge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a459b494b4813c66585cb1d0fdc455e0c">findEdge</a> (<a class="el" href="classEdge.html">Edge</a> e)</td></tr>
<tr class="memdesc:a459b494b4813c66585cb1d0fdc455e0c inherit pub_methods_classGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">find edge by edge  <br /></td></tr>
<tr class="separator:a459b494b4813c66585cb1d0fdc455e0c inherit pub_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5e0517e2979c54eebdafc2a9875e8f inherit pub_methods_classGraph"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#abb5e0517e2979c54eebdafc2a9875e8f">getNumVertex</a> () const</td></tr>
<tr class="memdesc:abb5e0517e2979c54eebdafc2a9875e8f inherit pub_methods_classGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of vertex in the graph  <br /></td></tr>
<tr class="separator:abb5e0517e2979c54eebdafc2a9875e8f inherit pub_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619ac583094079134074658e29463c0e inherit pub_methods_classGraph"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a619ac583094079134074658e29463c0e">getVertexSet</a> () const</td></tr>
<tr class="memdesc:a619ac583094079134074658e29463c0e inherit pub_methods_classGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the vertex set  <br /></td></tr>
<tr class="separator:a619ac583094079134074658e29463c0e inherit pub_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa06fc419a96315f9f566858c43bc7ad7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#aa06fc419a96315f9f566858c43bc7ad7">find_max_number_of_trains_to_stationAux</a> (string stationID)</td></tr>
<tr class="memdesc:aa06fc419a96315f9f566858c43bc7ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum number of trains that can be sent to a specific station without network congestion.  <br /></td></tr>
<tr class="separator:aa06fc419a96315f9f566858c43bc7ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb29dda9700f03e5278e9208541f2411"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#aeb29dda9700f03e5278e9208541f2411">findArgumentingPathWithDijka</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t, int &amp;mim)</td></tr>
<tr class="memdesc:aeb29dda9700f03e5278e9208541f2411"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an augmenting path using Dijkstra's algorithm from the source vertex to the sink vertex in the graph.  <br /></td></tr>
<tr class="separator:aeb29dda9700f03e5278e9208541f2411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e6d0c2088be25af90a639dc15547f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a01e6d0c2088be25af90a639dc15547f3">testAndVisitDisjka</a> (<a class="el" href="classMutablePriorityQueue.html">MutablePriorityQueue</a>&lt; <a class="el" href="classVertex.html">Vertex</a> &gt; &amp;q, <a class="el" href="classEdge.html">Edge</a> *e, <a class="el" href="classVertex.html">Vertex</a> *w, double residual, int dist_init)</td></tr>
<tr class="memdesc:a01e6d0c2088be25af90a639dc15547f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests and visits a vertex using Dijkstra's algorithm to find an augmenting path. This function tests and visits a vertex in the graph using Dijkstra's algorithm to find an augmenting path from the source vertex to the sink vertex. The function updates the distance, path, and visited status of the vertex if certain conditions are met, and inserts the vertex into a mutable priority queue for further exploration.  <br /></td></tr>
<tr class="separator:a01e6d0c2088be25af90a639dc15547f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17582f3a885211aacb0d898bf208934"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#ae17582f3a885211aacb0d898bf208934">find_vertexes_with_only_one_edge</a> ()</td></tr>
<tr class="memdesc:ae17582f3a885211aacb0d898bf208934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds vertices in the graph with only one incoming and one outgoing edge. This function iterates through all vertices in the graph and identifies those that have only one incoming and one outgoing edge. It stores these vertices in a vector and returns it.  <br /></td></tr>
<tr class="separator:ae17582f3a885211aacb0d898bf208934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b89b4bbc6b9be7c70c05f70caed1b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#ab8b89b4bbc6b9be7c70c05f70caed1b8">findArgumentingPath</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t)</td></tr>
<tr class="memdesc:ab8b89b4bbc6b9be7c70c05f70caed1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an augmenting path using breadth-first search from the source vertex to the sink vertex in the graph. This function uses breadth-first search to find an augmenting path from the source vertex to the sink vertex in the graph. It starts by setting all vertices as unvisited and the source vertex as visited, and then uses a queue to explore neighboring vertices. The function tests each vertex and edge it encounters and visits them if certain conditions are met. If the sink vertex is visited, the function returns true; otherwise, it returns false.  <br /></td></tr>
<tr class="separator:ab8b89b4bbc6b9be7c70c05f70caed1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5502807c0b1cc8debc68393c7c87f97c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a5502807c0b1cc8debc68393c7c87f97c">finMinResidualaLongPath</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t)</td></tr>
<tr class="memdesc:a5502807c0b1cc8debc68393c7c87f97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum residual capacity of an augmenting path from the source vertex to the sink vertex in the graph. This function finds the minimum residual capacity of an augmenting path from the source vertex to the sink vertex in the graph using the path stored in the vertices' path attribute. It iterates backwards from the sink vertex to the source vertex, checking the residual capacities of the edges on the path and updating the minimum value as necessary. The function returns the minimum residual capacity found.  <br /></td></tr>
<tr class="separator:a5502807c0b1cc8debc68393c7c87f97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e4f54daed842a3143773d5b01f1c6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a27e4f54daed842a3143773d5b01f1c6d">argumentFlowAlongPath</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t, int f)</td></tr>
<tr class="memdesc:a27e4f54daed842a3143773d5b01f1c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments the flow along the given path in the graph by the given amount. This function augments the flow along the given path in the graph by the given amount f, using the path stored in the vertices' path attribute. It iterates backwards from the sink vertex to the source vertex, updating the flow along each edge on the path by adding or subtracting the given amount, depending on the direction of the edge. The function does not return anything.  <br /></td></tr>
<tr class="separator:a27e4f54daed842a3143773d5b01f1c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237a2dd32b2b63884558827c1ecad54e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a237a2dd32b2b63884558827c1ecad54e">testAndVisit</a> (std::queue&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt; &amp;q, <a class="el" href="classEdge.html">Edge</a> *e, <a class="el" href="classVertex.html">Vertex</a> *w, double residual)</td></tr>
<tr class="memdesc:a237a2dd32b2b63884558827c1ecad54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the destination vertex of the given edge to the queue if it has not been visited and there is residual capacity on the edge. This function adds the destination vertex of the given edge to the queue if it has not been visited and there is residual capacity on the edge. The function does not return anything.  <br /></td></tr>
<tr class="separator:a237a2dd32b2b63884558827c1ecad54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5497c0ea4d4a6f8ac61e1aedb54d681"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#ac5497c0ea4d4a6f8ac61e1aedb54d681">finMinResidualaLongPathReducedConnectivity</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t)</td></tr>
<tr class="memdesc:ac5497c0ea4d4a6f8ac61e1aedb54d681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum residual capacity along the path from vertex s to vertex t in the graph using a modified version of Dijkstra's algorithm that considers edges with reduced connectivity.  <br /></td></tr>
<tr class="separator:ac5497c0ea4d4a6f8ac61e1aedb54d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee14331c95071554f9ae2138ea5a6a3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#aee14331c95071554f9ae2138ea5a6a3f">argumentFlowAlongPathReducedConnectivity</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t, int f)</td></tr>
<tr class="separator:aee14331c95071554f9ae2138ea5a6a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865d93733c877d75837727753a35b4f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a865d93733c877d75837727753a35b4f6">testAndVisitReducedConnectivity</a> (std::queue&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt; &amp;q, <a class="el" href="classEdge.html">Edge</a> *e, <a class="el" href="classVertex.html">Vertex</a> *w, double residual)</td></tr>
<tr class="memdesc:a865d93733c877d75837727753a35b4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function used in the Edmonds-Karp algorithm with reduced connectivity. The function checks if a vertex is visited and if there is still residual capacity on the edge. If both conditions are met, the vertex is marked as visited, its path is set to the edge and it is added to the queue.  <br /></td></tr>
<tr class="separator:a865d93733c877d75837727753a35b4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b2bcc3fb2a21fa8a0f8ce8dd97de70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphAlgorithms.html#a31b2bcc3fb2a21fa8a0f8ce8dd97de70">findArgumentingPathReducedConnectivity</a> (<a class="el" href="classVertex.html">Vertex</a> *s, <a class="el" href="classVertex.html">Vertex</a> *t)</td></tr>
<tr class="memdesc:a31b2bcc3fb2a21fa8a0f8ce8dd97de70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an augmenting path in a graph with reduced connectivity using the Edmonds-Karp algorithm.  <br /></td></tr>
<tr class="separator:a31b2bcc3fb2a21fa8a0f8ce8dd97de70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classGraph"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGraph')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classGraph.html">Graph</a></td></tr>
<tr class="memitem:acc3f19a6ff1f252681668fed49877cc0 inherit pro_methods_classGraph"><td class="memItemLeft" align="right" valign="top"><a id="acc3f19a6ff1f252681668fed49877cc0" name="acc3f19a6ff1f252681668fed49877cc0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>findVertexIdx</b> (const string &amp;id) const</td></tr>
<tr class="separator:acc3f19a6ff1f252681668fed49877cc0 inherit pro_methods_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classGraph"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classGraph')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classGraph.html">Graph</a></td></tr>
<tr class="memitem:aa9b0a6d8ad43c5eabaca5a7140bcc8b6 inherit pro_attribs_classGraph"><td class="memItemLeft" align="right" valign="top"><a id="aa9b0a6d8ad43c5eabaca5a7140bcc8b6" name="aa9b0a6d8ad43c5eabaca5a7140bcc8b6"></a>
std::vector&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertexSet</b></td></tr>
<tr class="separator:aa9b0a6d8ad43c5eabaca5a7140bcc8b6 inherit pro_attribs_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e61864da69191c1896a25a708d1a02d inherit pro_attribs_classGraph"><td class="memItemLeft" align="right" valign="top"><a id="a9e61864da69191c1896a25a708d1a02d" name="a9e61864da69191c1896a25a708d1a02d"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>distMatrix</b> = nullptr</td></tr>
<tr class="separator:a9e61864da69191c1896a25a708d1a02d inherit pro_attribs_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae09699c3616af3ebfcb1eb045f2b62 inherit pro_attribs_classGraph"><td class="memItemLeft" align="right" valign="top"><a id="a3ae09699c3616af3ebfcb1eb045f2b62" name="a3ae09699c3616af3ebfcb1eb045f2b62"></a>
int **&#160;</td><td class="memItemRight" valign="bottom"><b>pathMatrix</b> = nullptr</td></tr>
<tr class="separator:a3ae09699c3616af3ebfcb1eb045f2b62 inherit pro_attribs_classGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a27e4f54daed842a3143773d5b01f1c6d" name="a27e4f54daed842a3143773d5b01f1c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e4f54daed842a3143773d5b01f1c6d">&#9670;&#160;</a></span>argumentFlowAlongPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GraphAlgorithms::argumentFlowAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Augments the flow along the given path in the graph by the given amount. This function augments the flow along the given path in the graph by the given amount f, using the path stored in the vertices' path attribute. It iterates backwards from the sink vertex to the source vertex, updating the flow along each edge on the path by adding or subtracting the given amount, depending on the direction of the edge. The function does not return anything. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the source vertex </td></tr>
    <tr><td class="paramname">t</td><td>Pointer to the sink vertex </td></tr>
    <tr><td class="paramname">f</td><td>The amount by which to augment the flow along the path Time complexity: O(E), where E is the number of edges in the augmenting path, since the function iterates through each edge in the path only once to update the flow. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee14331c95071554f9ae2138ea5a6a3f" name="aee14331c95071554f9ae2138ea5a6a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee14331c95071554f9ae2138ea5a6a3f">&#9670;&#160;</a></span>argumentFlowAlongPathReducedConnectivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GraphAlgorithms::argumentFlowAlongPathReducedConnectivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function updates the flow of the edges along a path from source vertex s to target vertex t, with a given flow f, while considering reduced connectivity. The function starts from target vertex t, and follows the path back to source vertex s, updating the flow of the edges along the way. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to the source vertex of the path </td></tr>
    <tr><td class="paramname">t</td><td>pointer to the target vertex of the path </td></tr>
    <tr><td class="paramname">f</td><td>the flow to be added/subtracted along the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a7b5d8ca55c363d129a3aebdd6c93f53e" name="a7b5d8ca55c363d129a3aebdd6c93f53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5d8ca55c363d129a3aebdd6c93f53e">&#9670;&#160;</a></span>edmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GraphAlgorithms::edmondsKarp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum flow from source to sink using the Edmonds-Karp algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The ID of the source vertex. </td></tr>
    <tr><td class="paramname">target</td><td>The ID of the sink vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum flow from source to sink.</dd></dl>
<p>This function has a time complexity of O(V * E^2), where V is the number of vertices and E is the number of edges in the graph. </p>

</div>
</div>
<a id="a2e12d57cdf79b52cc9e259ebcb6c1a85" name="a2e12d57cdf79b52cc9e259ebcb6c1a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e12d57cdf79b52cc9e259ebcb6c1a85">&#9670;&#160;</a></span>edmondsKarpReducedConnectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GraphAlgorithms::edmondsKarpReducedConnectivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classEdge.html">Edge</a> * &gt;&#160;</td>
          <td class="paramname"><em>edgesReduced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the Edmonds-Karp algorithm with reduced connectivity to find the maximum flow from s to t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>The target vertex. </td></tr>
    <tr><td class="paramname">edgesReduced</td><td>A vector of edges to be marked as "reduced connectivity", meaning that they will not be considered in the search for argumenting paths. This is useful when trying to avoid paths that cross certain edges in the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum flow from s to t. </dd></dl>

</div>
</div>
<a id="a58685fb1a172cb92e9ec0902722c63be" name="a58685fb1a172cb92e9ec0902722c63be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58685fb1a172cb92e9ec0902722c63be">&#9670;&#160;</a></span>edmondsKarpWithDijska()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GraphAlgorithms::edmondsKarpWithDijska </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>price</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum flow from source to sink using the Edmonds-Karp algorithm with Dijkstra's algorithm to compute the minimum residual capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>Pointer to the sink vertex. </td></tr>
    <tr><td class="paramname">price</td><td>Reference to an integer variable to store the minimum residual capacity of the augmenting path found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum flow from source to sink. This function implements the Edmonds-Karp algorithm, which is a variation of the Ford-Fulkerson algorithm. It uses breadth-first search to find an augmenting path with the minimum residual capacity and updates the flow in the edges along that path. Dijkstra's algorithm is used to compute the minimum residual capacity of the augmenting path. The time complexity of this function is O(V^2 * E^2), where V is the number of vertices and E is the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a7743bb7b0ca9666233bb6529ffb112b7" name="a7743bb7b0ca9666233bb6529ffb112b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7743bb7b0ca9666233bb6529ffb112b7">&#9670;&#160;</a></span>find_max_flow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structMaxTrainPair.html">MaxTrainPair</a> &gt; GraphAlgorithms::find_max_flow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the maximum flow between all pairs of vertices in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="structMaxTrainPair.html">MaxTrainPair</a> objects representing the maximum flow between each pair of vertices.</dd></dl>
<p>This function has a time complexity of O(V^3 * E^2), where V is the number of vertices and E is the number of edges in the graph. </p>

</div>
</div>
<a id="a8fc6922f78c80b5480e3e2f44d05bb02" name="a8fc6922f78c80b5480e3e2f44d05bb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc6922f78c80b5480e3e2f44d05bb02">&#9670;&#160;</a></span>find_max_number_of_trains_to_station()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GraphAlgorithms::find_max_number_of_trains_to_station </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>stationID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum number of trains that can be sent to a given station. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stationID</td><td>The ID of the station. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of trains that can be sent to the station. This function uses the Edmonds-Karp algorithm to calculate the maximum number of trains that can be sent to a given station based on the current network congestion. It adds a temporary source vertex and connects it to all vertices with only one outgoing edge, which allows the algorithm to compute the maximum flow from the temporary source to the target station. This function has a time complexity of O(V * E^2), where V is the number of vertices and E is the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a27b4edc0d50b038a18315d1f91fec26c" name="a27b4edc0d50b038a18315d1f91fec26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b4edc0d50b038a18315d1f91fec26c">&#9670;&#160;</a></span>find_max_number_of_trains_to_station_with_congested_network()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GraphAlgorithms::find_max_number_of_trains_to_station_with_congested_network </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>stationID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classEdge.html">Edge</a> * &gt;&#160;</td>
          <td class="paramname"><em>edgesReduced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum number of trains that can be sent to a specific station with a congested network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stationID</td><td>The ID of the station to calculate the maximum number of trains for. </td></tr>
    <tr><td class="paramname">edgesReduced</td><td>A vector of edges to be removed from the graph to simulate congestion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of trains that can be sent to the specified station with the given network congestion. This function first finds the target vertex corresponding to the provided station ID, and then creates a source vertex with a unique ID of "DELETE" to simulate the removal of edges from the graph. The function then calls the Edmonds-Karp algorithm with the reduced edge set and returns the resulting maximum flow. This function can be used to calculate the maximum number of trains that can be sent to a station with a congested network. </dd></dl>

</div>
</div>
<a id="aa06fc419a96315f9f566858c43bc7ad7" name="aa06fc419a96315f9f566858c43bc7ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06fc419a96315f9f566858c43bc7ad7">&#9670;&#160;</a></span>find_max_number_of_trains_to_stationAux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GraphAlgorithms::find_max_number_of_trains_to_stationAux </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>stationID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum number of trains that can be sent to a specific station without network congestion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stationID</td><td>The ID of the station to calculate the maximum number of trains for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of trains that can be sent to the specified station without network congestion. This function first finds the target vertex corresponding to the provided station ID, and then creates a source vertex with a unique ID of "DELETE". The function then calls the Edmonds-Karp algorithm and returns the resulting maximum flow. This function can be used to calculate the maximum number of trains that can be sent to a station without network congestion. </dd></dl>

</div>
</div>
<a id="ae17582f3a885211aacb0d898bf208934" name="ae17582f3a885211aacb0d898bf208934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17582f3a885211aacb0d898bf208934">&#9670;&#160;</a></span>find_vertexes_with_only_one_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt; GraphAlgorithms::find_vertexes_with_only_one_edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds vertices in the graph with only one incoming and one outgoing edge. This function iterates through all vertices in the graph and identifies those that have only one incoming and one outgoing edge. It stores these vertices in a vector and returns it. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to vertices with only one incoming and one outgoing edge Time complexity: O(V), where V is the number of vertices in the graph, due to the iteration over all vertices and the constant-time operations to check the size of adjacency lists. </dd></dl>

</div>
</div>
<a id="ab8b89b4bbc6b9be7c70c05f70caed1b8" name="ab8b89b4bbc6b9be7c70c05f70caed1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b89b4bbc6b9be7c70c05f70caed1b8">&#9670;&#160;</a></span>findArgumentingPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GraphAlgorithms::findArgumentingPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an augmenting path using breadth-first search from the source vertex to the sink vertex in the graph. This function uses breadth-first search to find an augmenting path from the source vertex to the sink vertex in the graph. It starts by setting all vertices as unvisited and the source vertex as visited, and then uses a queue to explore neighboring vertices. The function tests each vertex and edge it encounters and visits them if certain conditions are met. If the sink vertex is visited, the function returns true; otherwise, it returns false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the source vertex </td></tr>
    <tr><td class="paramname">t</td><td>Pointer to the sink vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an augmenting path was found, false otherwise Time complexity: O(E+V), where E is the number of edges and V is the number of vertices in the graph, due to the traversal of all edges and vertices in the graph in the worst case scenario. </dd></dl>

</div>
</div>
<a id="a31b2bcc3fb2a21fa8a0f8ce8dd97de70" name="a31b2bcc3fb2a21fa8a0f8ce8dd97de70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b2bcc3fb2a21fa8a0f8ce8dd97de70">&#9670;&#160;</a></span>findArgumentingPathReducedConnectivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GraphAlgorithms::findArgumentingPathReducedConnectivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an augmenting path in a graph with reduced connectivity using the Edmonds-Karp algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">t</td><td>The sink vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is an augmenting path from s to t, false otherwise. </dd></dl>

</div>
</div>
<a id="aeb29dda9700f03e5278e9208541f2411" name="aeb29dda9700f03e5278e9208541f2411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb29dda9700f03e5278e9208541f2411">&#9670;&#160;</a></span>findArgumentingPathWithDijka()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GraphAlgorithms::findArgumentingPathWithDijka </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>mim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds an augmenting path using Dijkstra's algorithm from the source vertex to the sink vertex in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the source vertex </td></tr>
    <tr><td class="paramname">t</td><td>Pointer to the sink vertex </td></tr>
    <tr><td class="paramname">mine</td><td>Reference to an integer that will store the minimum weight of the path found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an augmenting path was found, false otherwise</dd></dl>
<p>Time Complexity: O((E+V)logV), where E is the number of edges and V is the number of vertices in the graph. This is because the function uses Dijkstra's algorithm, which has a time complexity of O((E+V)logV), to find the augmenting path. </p>

</div>
</div>
<a id="abff3651d8436f69ccecad7d1b6eab42e" name="abff3651d8436f69ccecad7d1b6eab42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff3651d8436f69ccecad7d1b6eab42e">&#9670;&#160;</a></span>findVertexsInDistricts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt; GraphAlgorithms::findVertexsInDistricts </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>district</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a vector of all vertices in the graph that belong to a specific district. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">district</td><td>The name of the district to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vertices that belong to the specified district. This function loops through all the vertices in the graph and retrieves vertices whose district name matches the provided parameter. If a vertex is found that belongs to the specified district, it is added to the result vector. The result vector may be empty if no vertices belong to the specified district. </dd></dl>

</div>
</div>
<a id="a12e07a19a5cc26bb9a453a29857bd3ce" name="a12e07a19a5cc26bb9a453a29857bd3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e07a19a5cc26bb9a453a29857bd3ce">&#9670;&#160;</a></span>findVertexsInMunicipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt; GraphAlgorithms::findVertexsInMunicipe </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>municipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a vector of all vertices in the graph that belong to a specific municipality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">municipe</td><td>The name of the municipality to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vertices that belong to the specified municipality. This function loops through all the vertices in the graph and retrieves vertices whose municipality name matches the provided parameter. If a vertex is found that belongs to the specified municipality, it is added to the result vector. The result vector may be empty if no vertices belong to the specified municipality. </dd></dl>

</div>
</div>
<a id="a5502807c0b1cc8debc68393c7c87f97c" name="a5502807c0b1cc8debc68393c7c87f97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5502807c0b1cc8debc68393c7c87f97c">&#9670;&#160;</a></span>finMinResidualaLongPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GraphAlgorithms::finMinResidualaLongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the minimum residual capacity of an augmenting path from the source vertex to the sink vertex in the graph. This function finds the minimum residual capacity of an augmenting path from the source vertex to the sink vertex in the graph using the path stored in the vertices' path attribute. It iterates backwards from the sink vertex to the source vertex, checking the residual capacities of the edges on the path and updating the minimum value as necessary. The function returns the minimum residual capacity found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the source vertex </td></tr>
    <tr><td class="paramname">t</td><td>Pointer to the sink vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum residual capacity of an augmenting path from the source vertex to the sink vertex in the graph Time complexity: O(E), where E is the number of edges in the augmenting path, since the function iterates through each edge in the path only once to calculate the minimum residual capacity. </dd></dl>

</div>
</div>
<a id="ac5497c0ea4d4a6f8ac61e1aedb54d681" name="ac5497c0ea4d4a6f8ac61e1aedb54d681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5497c0ea4d4a6f8ac61e1aedb54d681">&#9670;&#160;</a></span>finMinResidualaLongPathReducedConnectivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GraphAlgorithms::finMinResidualaLongPathReducedConnectivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the minimum residual capacity along the path from vertex s to vertex t in the graph using a modified version of Dijkstra's algorithm that considers edges with reduced connectivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the source vertex </td></tr>
    <tr><td class="paramname">t</td><td>Pointer to the sink vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum residual capacity along the path from vertex s to vertex t Time Complexity: O((E+V)logV), where E is the number of edges and V is the number of vertices in the graph. This is because the function uses a modified version of Dijkstra's algorithm to find the minimum residual capacity, which has a time complexity of O((E+V)logV). </dd></dl>

</div>
</div>
<a id="a08934472eb8ac30f48bdb5a44d8dde8a" name="a08934472eb8ac30f48bdb5a44d8dde8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08934472eb8ac30f48bdb5a44d8dde8a">&#9670;&#160;</a></span>getDistrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string &gt; GraphAlgorithms::getDistrics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a vector with the names of all the districts present in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector with the names of all the districts present in the graph. </dd></dl>

</div>
</div>
<a id="aee5c7a72d06e03f76f41a117f066de8b" name="aee5c7a72d06e03f76f41a117f066de8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5c7a72d06e03f76f41a117f066de8b">&#9670;&#160;</a></span>getMunicipes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string &gt; GraphAlgorithms::getMunicipes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a vector with the names of all the municipalities present in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector with the names of all the municipalities present in the graph. </dd></dl>

</div>
</div>
<a id="a237a2dd32b2b63884558827c1ecad54e" name="a237a2dd32b2b63884558827c1ecad54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237a2dd32b2b63884558827c1ecad54e">&#9670;&#160;</a></span>testAndVisit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GraphAlgorithms::testAndVisit </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>residual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the destination vertex of the given edge to the queue if it has not been visited and there is residual capacity on the edge. This function adds the destination vertex of the given edge to the queue if it has not been visited and there is residual capacity on the edge. The function does not return anything. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Reference to the queue of vertices to visit </td></tr>
    <tr><td class="paramname">e</td><td>Pointer to the edge to test </td></tr>
    <tr><td class="paramname">w</td><td>Pointer to the destination vertex of the edge </td></tr>
    <tr><td class="paramname">residual</td><td>The residual capacity of the edge Time complexity: O(1), since the function only performs a constant number of operations regardless of the size of the input. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01e6d0c2088be25af90a639dc15547f3" name="a01e6d0c2088be25af90a639dc15547f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e6d0c2088be25af90a639dc15547f3">&#9670;&#160;</a></span>testAndVisitDisjka()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GraphAlgorithms::testAndVisitDisjka </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMutablePriorityQueue.html">MutablePriorityQueue</a>&lt; <a class="el" href="classVertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dist_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests and visits a vertex using Dijkstra's algorithm to find an augmenting path. This function tests and visits a vertex in the graph using Dijkstra's algorithm to find an augmenting path from the source vertex to the sink vertex. The function updates the distance, path, and visited status of the vertex if certain conditions are met, and inserts the vertex into a mutable priority queue for further exploration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A mutable priority queue of vertices </td></tr>
    <tr><td class="paramname">e</td><td>The edge used to reach the vertex being tested and visited </td></tr>
    <tr><td class="paramname">w</td><td>The vertex being tested and visited </td></tr>
    <tr><td class="paramname">residual</td><td>The residual capacity of the edge used to reach the vertex </td></tr>
    <tr><td class="paramname">dist_init</td><td>The initial distance from the source vertex to the vertex being tested and visited </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void Time complexity: O(logV), where V is the number of vertices in the graph, due to the insertion operation on the priority queue. </dd></dl>

</div>
</div>
<a id="a865d93733c877d75837727753a35b4f6" name="a865d93733c877d75837727753a35b4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865d93733c877d75837727753a35b4f6">&#9670;&#160;</a></span>testAndVisitReducedConnectivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GraphAlgorithms::testAndVisitReducedConnectivity </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; <a class="el" href="classVertex.html">Vertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEdge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>residual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function used in the Edmonds-Karp algorithm with reduced connectivity. The function checks if a vertex is visited and if there is still residual capacity on the edge. If both conditions are met, the vertex is marked as visited, its path is set to the edge and it is added to the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A reference to the queue of vertices to be visited in the algorithm. </td></tr>
    <tr><td class="paramname">e</td><td>A pointer to the edge being tested. </td></tr>
    <tr><td class="paramname">w</td><td>A pointer to the vertex to be checked for visitation. </td></tr>
    <tr><td class="paramname">residual</td><td>The remaining residual capacity of the edge being tested. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a263885df52809e4bac2d5a13cb04bb80" name="a263885df52809e4bac2d5a13cb04bb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263885df52809e4bac2d5a13cb04bb80">&#9670;&#160;</a></span>TopKDistricsForWithMoreTraficPotencial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structFlowPerMunicOrDis.html">FlowPerMunicOrDis</a> &gt; GraphAlgorithms::TopKDistricsForWithMoreTraficPotencial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the top k districts with the highest traffic potential. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The number of districts to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="structFlowPerMunicOrDis.html">FlowPerMunicOrDis</a> objects representing the top k districts with the highest traffic potential. This function calculates the number of trains that can travel between every pair of stations within each district, and returns the k districts with the highest traffic potential. It achieves this by calling the edmondsKarpReducedConnectivity function for each pair of stations in each district, while excluding any edges that connect stations in different districts (specified in the blackList parameter). The function returns a vector of <a class="el" href="structFlowPerMunicOrDis.html">FlowPerMunicOrDis</a> objects, each representing a district and its associated traffic potential, sorted in decreasing order of traffic potential. If k is greater than the number of districts, the function returns all districts. </dd></dl>

</div>
</div>
<a id="a8cdb089cabef0c3a34d3d7fa38a3f687" name="a8cdb089cabef0c3a34d3d7fa38a3f687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdb089cabef0c3a34d3d7fa38a3f687">&#9670;&#160;</a></span>TopKMunicipesForWithMoreTraficPotencial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structFlowPerMunicOrDis.html">FlowPerMunicOrDis</a> &gt; GraphAlgorithms::TopKMunicipesForWithMoreTraficPotencial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the top k municipalities with the most traffic potential based on the number of trains that can be routed between stations within each municipality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The number of top municipalities to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="structFlowPerMunicOrDis.html">FlowPerMunicOrDis</a> structs representing the top k municipalities and their traffic potential. This function iterates through all municipalities in the graph, and for each municipality it computes the maximum number of trains that can be routed between pairs of stations within the municipality using the Edmonds-Karp algorithm. The result is a vector of <a class="el" href="structFlowPerMunicOrDis.html">FlowPerMunicOrDis</a> structs, where each struct contains the name of a municipality and the number of trains that can be routed between stations within the municipality. The vector is sorted in descending order of traffic potential, and only the top k municipalities are returned. This function has a time complexity of O(M * V^2 * E^2), where M is the number of municipalities in the graph, V is the number of vertices, and E is the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a1a40093e6b997399ccb1a50a70c0c4ac" name="a1a40093e6b997399ccb1a50a70c0c4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a40093e6b997399ccb1a50a70c0c4ac">&#9670;&#160;</a></span>TopKStationsThatAreAffectedByReducedConectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structAfectedStation.html">AfectedStation</a> &gt; GraphAlgorithms::TopKStationsThatAreAffectedByReducedConectivity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structEdgeSearch.html">EdgeSearch</a> &gt;&#160;</td>
          <td class="paramname"><em>unusedEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the top K stations that are most affected by a reduced connectivity scenario caused by the removal of certain edges. </p>
<p>This function computes the number of trains that can still reach each station in the graph after removing a set of edges, and then returns the top K stations that have the biggest difference between the number of trains that can reach them before and after the removal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The number of stations to return. </td></tr>
    <tr><td class="paramname">unusableEdges</td><td>A vector containing <a class="el" href="structEdgeSearch.html">EdgeSearch</a> objects that represent the edges to be removed from the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="structAfectedStation.html">AfectedStation</a> objects, sorted by the magnitude of the difference between the number of trains that can reach the station before and after removing the edges. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="GraphAlgorithms_8h_source.html">GraphAlgorithms.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
